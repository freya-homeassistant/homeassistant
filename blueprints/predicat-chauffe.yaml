blueprint:
  name: Chauffage – Calcul prochaine chauffe (slope VT + calendrier de présence)
  description: >
    Calcule l'heure optimale de démarrage de chauffe à partir d'un calendrier de présence,
    du slope (°C/h) d'un Versatile Thermostat et d'une consigne confort, puis la stocke
    dans un input_datetime.
  domain: automation
  input:
    thermostat:
      name: Thermostat Versatile
      selector:
        entity:
          domain: climate

    slope_sensor:
      name: Slope VT (°C/h)
      selector:
        entity:
          domain: sensor

    consigne_confort:
      name: Consigne confort
      selector:
        entity:
          domain: number

    inertie_max_minutes:
      name: Inertie max (minutes)
      description: Limite l'anticipation maximale calculée à partir du slope.
      default: 180
      selector:
        number:
          min: 0
          max: 600
          step: 5

    calendrier_presence:
      name: Calendrier Présence
      selector:
        entity:
          domain: calendar

    prochaine_chauffe:
      name: Stockage prochaine chauffe
      description: input_datetime qui recevra l'heure calculée de la prochaine chauffe.
      selector:
        entity:
          domain: input_datetime

mode: single

trigger:
  - platform: homeassistant
    event: start

  - platform: time_pattern
    minutes: "/5"

  - platform: state
    entity_id: !input calendrier_presence

action:
  - variables:
      thermostat_entity: !input thermostat
      slope_sensor_entity: !input slope_sensor
      consigne_confort_entity: !input consigne_confort
      inertie_max_minutes_value: !input inertie_max_minutes
      calendrier_presence_entity: !input calendrier_presence
      prochaine_chauffe_entity: !input prochaine_chauffe

  - service: calendar.get_events
    target:
      entity_id: !input calendrier_presence
    data:
      start_date_time: "{{ now().isoformat() }}"
      end_date_time: "{{ (now() + timedelta(days=7)).isoformat() }}"
    response_variable: presence_events

  - variables:
      next_event_start: >
        {% set payload = presence_events.get(calendrier_presence_entity) %}
        {% if payload is none %}
          {{ none }}
        {% else %}
          {% set evts = payload.get('events', []) %}
          {% if evts | length == 0 %}
            {{ none }}
          {% else %}
            {{ evts[0].get('start') }}
          {% endif %}
        {% endif %}

      debut_presence: >
        {{ as_timestamp(next_event_start, default=none) }}

      ts_final: >
        {% if debut_presence is none %}
          {{ none }}
        {% else %}
          {% set temp_actuelle = state_attr(thermostat_entity, 'current_temperature') | float(0) %}
          {% set temp_cible = states(consigne_confort_entity) | float(0) %}
          {% set delta = (temp_cible - temp_actuelle) | float(0) %}

          {% set raw_slope = states(slope_sensor_entity) | replace(',', '.') | float(0) %}
          {% set slope_per_min = (raw_slope / 60) if raw_slope > 0 else 0 %}

          {% if slope_per_min > 0 and delta > 0 %}
            {% set minutes = (delta / slope_per_min) | round(0, 'ceil') %}
          {% else %}
            {% set minutes = 0 %}
          {% endif %}

          {% set max_i = inertie_max_minutes_value | int(0) %}
          {% if max_i > 0 %}
            {% set minutes = [minutes | int(0), max_i] | min %}
          {% endif %}

          {{ (debut_presence - (minutes | int(0) * 60)) | int }}
        {% endif %}

      stored_ts: >
        {% set val = states(prochaine_chauffe_entity) %}
        {% if val in ['unknown','unavailable',''] %}
          {{ none }}
        {% else %}
          {{ as_timestamp(val, default=none) }}
        {% endif %}

  - choose:
      - conditions:
          - condition: template
            value_template: >
              {{ ts_final is not none and (stored_ts is none or (ts_final | int) != (stored_ts | int)) }}
        sequence:
          - service: input_datetime.set_datetime
            target:
              entity_id: !input prochaine_chauffe
            data:
              timestamp: "{{ ts_final }}"
